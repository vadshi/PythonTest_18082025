### Тестирование исключений

`pytest.raises()` используется для тестирования возможных исключений

### Структурирование тестовых функций

Рекомендуется обязательно добавлять assert в конце тестовых функций.
Это настолько распространённая рекомендация, что у неё есть как минимум два названия: `Arrange-Act-Assert` и `Given-When-Then`.

Билл Уэйк впервые назвал шаблон `Arrange-Act-Assert` в 2001 году.
Кент Бек позже популяризировал эту практику как часть разработки через тестирование (TDD).
В разработке, основанной на поведении (BDD), используется термин `Given-When-Then` — шаблон Ивана Мура, популяризированный Дэном Нортом.

Независимо от названий этапов, цель одна: разделить тест на этапы.
Разделение на этапы даёт множество преимуществ. Такое разделение чётко разделяет части теста: «подготовку к выполнению чего-либо», «выполнение чего-либо» и «проверку работоспособности». Это позволяет разработчику тестов сосредоточиться на каждой части и чётко понимать, что именно тестируется. Распространенным антипаттерном является использование шаблона `Arrange-Assert-Act-Assert-Act-Assert…`, где множество действий, за которыми следуют проверки состояния или поведения, проверяют рабочий процесс. Это кажется разумным до тех пор, пока тест не провалится. Любое из действий могло привести к сбою, поэтому тест не фокусируется на тестировании одного поведения. Или же причиной сбоя могла быть настройка в `Arrange`. Этот шаблон чередования утверждений создаёт тесты, которые сложно отлаживать и поддерживать, поскольку последующие разработчики не понимают первоначального замысла теста. 

Придерживание шаблонов `Given-When-Then` или `Arrange-Act-Assert` сохраняет целенаправленность теста и делает его более удобным для поддержки.

- `Given/Arrange` — начальное состояние. Здесь вы настраиваете данные или среду для подготовки к действию.
- `When/Act` — выполняется какое-то действие. Это фокус теста — поведение, которое мы пытаемся проверить.
- `Then/Assert` — должен быть достигнут некий ожидаемый результат или конечное состояние. В конце теста мы убеждаемся, что действие привело к ожидаемому поведению.

### Группировка тестов с помощью классов
1. Создадим тестовый класс
```python
from tasks import Task


class TestEquality:
    def test_equality(self):
        c1 = Task("something", "petr", "todo", 123)
        c2 = Task("something", "petr", "todo", 123)
        assert c1 == c2

    def test_equality_with_diff_ids(self):
        c1 = Task("something", "petr", "todo", 123)
        c2 = Task("something", "petr", "todo", 4567)
        assert c1 == c2

    def test_inequality(self):
        c1 = Task("something", "petr", "todo", 123)
        c2 = Task("completely different", "anna", "done", 123)
        assert c1 != c2
```
2. Запустим его в термиале
```
pytest -v test_classes.py::TestEquality
```

3. Можно запустить только нужный нам метод
```
pytest -v test_classes.py::TestEquality::test_equality
```

### Запуск отдельных тестов


Syntax |Subset
-------|--------
Запуск отдельного метода | pytest path/test_module.py::TestClass::test_method
Все методы в классе | pytest path/test_module.py::TestClass
Запуск отдельной функции |pytest path/test_module.py::test_function
Все тесты в модуле | pytest path/test_module.py
Все тесты в директории | pytest path
Запуск тестов по шаблону | pytest -k pattern

Примеры запуска по шаблону
```
pytest -v -k TestEquality
```
```
pytest -v --tb=no -k equality
```
```
pytest -v --tb=no -k "equality and not equality_fail"
```

Ключевые слова `and`, `not`, `or` и скобки разрешены для создания сложных выражений.
```
pytest -v --tb=no -k "(dict or ids) and not TestEquality"
```